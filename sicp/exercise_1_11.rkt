#lang scheme

; Recursive process
(define (f n)
  (if (< n 3)
      n
      (+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))))))

; I'm going to evaluate the procedure in order to verify if it is truly
; a recursive process:

; Applicative order evaluation
; (f 4)
; (+ (f (- 4 1)) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (f 3) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ (f (- 3 1)) (* 2 (f (- 3 2))) (* 3 (f (- 3 3)))) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ (f 2) (* 2 (f (- 3 2))) (* 3 (f (- 3 3)))) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ 2 (* 2 (f (- 3 2))) (* 3 (f (- 3 3)))) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ 2 (* 2 (f 1)) (* 3 (f (- 3 3)))) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ 2 (* 2 1) (* 3 (f (- 3 3)))) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ 2 2 (* 3 (f (- 3 3)))) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ 2 2 (* 3 (f 0))) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ 2 2 (* 3 0)) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ (+ 2 2 0) (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ 4 (* 2 (f (- 4 2))) (* 3 (f (- 4 3))))
; (+ 4 (* 2 (f 2)) (* 3 (f (- 4 3))))
; (+ 4 (* 2 2) (* 3 (f (- 4 3))))
; (+ 4 4 (* 3 (f (- 4 3))))
; (+ 4 4 (* 3 (f 1)))
; (+ 4 4 (* 3 1))
; (+ 4 4 3)

;(+ (f (- n 1)) (* 2 (f (- n 2))) (* 3 (f (- n 3))))
; Normal order evaluation
; (f 4)
; (+ (f 3) (* 2 (f 2)) (* 3 (f 1)))
; (+ (+ (f 2) (* 2 (f 1)) (* 3 (f 0))) (* 2 2) (* 3 1))
; (+ (+ 2 (* 2 1) (* 3 0)) (* 2 2) (* 3 1))
; (+ (+ 2 2 0) (* 2 2) (* 3 1))
; (+ 4 (* 2 2) (* 3 1))
; (+ 4 4 (* 3 1))
; (+ 4 4 3)

; Iterative process
(define (f-iter a b c counter)
  (if (= counter 0)
      c
      (f-iter (+ a (* 2 b) (* 3 c)) a b (- counter 1))))

(define (f.v2 n)
  (f-iter 2 1 0 n))